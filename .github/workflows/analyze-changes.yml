name: Analyze Changes

on:
  workflow_call:
    inputs:
      branch_name:
        description: "Nome da branch (ex: 1.0.14+1)"
        required: true
        type: string
    outputs:
      action:
        description: "AÃ§Ã£o a ser executada (release/patch)"
        value: ${{ jobs.analyze.outputs.action }}
      current-version:
        description: "VersÃ£o atual"
        value: ${{ jobs.analyze.outputs.current-version }}
      new-version:
        description: "Nova versÃ£o"
        value: ${{ jobs.analyze.outputs.new-version }}
      should-proceed:
        description: "Deve prosseguir com pipeline"
        value: ${{ jobs.analyze.outputs.should-proceed }}
      change-type:
        description: "Tipo de mudanÃ§a (major/minor/patch)"
        value: ${{ jobs.analyze.outputs.change-type }}
      release-notes:
        description: "Notas da release"
        value: ${{ jobs.analyze.outputs.release-notes }}
    secrets:
      SHOREBIRD_TOKEN:
        required: true

jobs:
  analyze:
    runs-on: windows-latest
    outputs:
      action: ${{ steps.decision.outputs.action }}
      current-version: ${{ steps.version.outputs.current-version }}
      new-version: ${{ steps.version.outputs.new-version }}
      should-proceed: ${{ steps.decision.outputs.should-proceed }}
      change-type: ${{ steps.analyze.outputs.change-type }}
      release-notes: ${{ steps.analyze.outputs.release-notes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Pipeline Validation
        shell: powershell
        run: |
          Write-Output "ğŸ” ValidaÃ§Ã£o inicial da pipeline..."
          Write-Output ""
          Write-Output "ğŸ“‹ InformaÃ§Ãµes do contexto:"
          Write-Output "  Branch: ${{ inputs.branch_name }}"
          Write-Output "  Repository: ${{ github.repository }}"
          Write-Output "  Actor: ${{ github.actor }}"
          Write-Output "  Event: ${{ github.event_name }}"
          Write-Output "  SHA: ${{ github.sha }}"
          Write-Output "  Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
          Write-Output ""
          
          # Verificar se temos acesso aos secrets necessÃ¡rios
          if ("${{ secrets.SHOREBIRD_TOKEN }}" -ne "") {
            Write-Output "âœ… SHOREBIRD_TOKEN disponÃ­vel"
          } else {
            Write-Output "âŒ SHOREBIRD_TOKEN nÃ£o configurado!"
            Write-Output "âš ï¸ Pipeline pode falhar nas etapas do Shorebird"
          }
          
          # Verificar estrutura do projeto
          Write-Output "ğŸ“‚ Verificando estrutura do projeto..."
          if (Test-Path "pubspec.yaml") {
            Write-Output "âœ… pubspec.yaml encontrado"
          } else {
            Write-Output "âŒ pubspec.yaml nÃ£o encontrado!"
            throw "Projeto Flutter invÃ¡lido - pubspec.yaml nÃ£o encontrado"
          }
          
          if (Test-Path "lib") {
            Write-Output "âœ… Pasta lib/ encontrada"
          } else {
            Write-Output "âš ï¸ Pasta lib/ nÃ£o encontrada"
          }
          
          Write-Output "âœ… ValidaÃ§Ã£o inicial concluÃ­da"

      - name: Setup Shorebird (for verification)
        uses: shorebirdtech/setup-shorebird@v1
        with:
          cache: true

      - name: Analyze Code Changes
        id: analyze
        shell: powershell
        run: |
          Write-Output "ğŸ” Analisando mudanÃ§as no cÃ³digo..."

          # Obter commits desde o Ãºltimo push (com fallback para commits recentes)
          try {
            $commits = git log --oneline -10 --format="%s" 2>$null
            if (-not $commits) {
              Write-Output "âš ï¸ Nenhum commit encontrado, usando fallback"
              $commits = @("feat: initial commit")
            }
          } catch {
            Write-Output "âš ï¸ Erro ao obter commits, usando fallback"
            $commits = @("feat: initial commit")
          }
          
          # Obter arquivos modificados (com fallback)
          try {
            $changedFiles = git diff --name-only HEAD~1..HEAD 2>$null
            if (-not $changedFiles) {
              Write-Output "â„¹ï¸ Nenhum arquivo modificado detectado (possÃ­vel primeiro commit)"
              # Para primeiro commit, assumir mudanÃ§as em arquivos importantes
              $changedFiles = @("lib/main.dart", "pubspec.yaml")
            }
          } catch {
            Write-Output "âš ï¸ Erro ao obter arquivos modificados, usando fallback"
            $changedFiles = @("lib/main.dart")
          }

          Write-Output "ğŸ“ Commits analisados:"
          $commits | ForEach-Object { Write-Output "  - $_" }

          Write-Output "ğŸ“ Arquivos analisados:"
          $changedFiles | ForEach-Object { Write-Output "  - $_" }

          # Inicializar flags de anÃ¡lise
          $isBreakingChange = $false
          $isMajorFeature = $false
          $hasNewDependencies = $false
          $hasNativeChanges = $false
          $hasInfraChanges = $false
          $isPatchOnly = $true

          # Analisar arquivos modificados
          foreach ($file in $changedFiles) {
            switch -Regex ($file) {
              "^pubspec\.yaml$" { 
                # Verificar se realmente adicionou dependÃªncias
                try {
                  $pubspecDiff = git diff HEAD~1..HEAD pubspec.yaml 2>$null
                  if ($pubspecDiff -and ($pubspecDiff -like "*dependencies:*" -or $pubspecDiff -like "*+*")) {
                    $hasNewDependencies = $true
                    $isPatchOnly = $false
                    Write-Output "  ğŸ“¦ Novas dependÃªncias detectadas"
                  }
                } catch {
                  Write-Output "  ğŸ“¦ MudanÃ§a em pubspec.yaml detectada"
                }
              }
              "^(android|ios|windows|macos|linux)/" { 
                $hasNativeChanges = $true
                $isPatchOnly = $false
                Write-Output "  ğŸ”§ MudanÃ§as nativas detectadas: $file"
              }
              "^lib/main\.dart$" { 
                Write-Output "  ğŸ—ï¸ MudanÃ§a em main.dart detectada"
                $isPatchOnly = $false
              }
              "^lib/core/" { 
                Write-Output "  ğŸ—ï¸ MudanÃ§a de infraestrutura detectada: $file"
                $isPatchOnly = $false
              }
              "^\.github/workflows/" {
                $hasInfraChanges = $true
                Write-Output "  âš™ï¸ MudanÃ§as de CI/CD detectadas: $file"
              }
              "\.dart$" {
                Write-Output "  ğŸ“ CÃ³digo Dart modificado: $file"
              }
            }
          }

          # Analisar commits para padrÃµes de conventional commits
          foreach ($commit in $commits) {
            switch -Regex ($commit) {
              "(BREAKING|!:)" { 
                $isBreakingChange = $true
                $isPatchOnly = $false
                Write-Output "  ğŸ’¥ Breaking change detectado: $commit"
              }
              "^(feat|feature)(\(.+\))?:" { 
                $isMajorFeature = $true
                $isPatchOnly = $false
                Write-Output "  âœ¨ Nova feature detectada: $commit"
              }
              "^(fix|bugfix)(\(.+\))?:" {
                Write-Output "  ğŸ› Bug fix detectado: $commit"
              }
              "^(style|refactor|perf|docs)(\(.+\))?:" {
                Write-Output "  ğŸ”§ Melhoria detectada: $commit"
              }
              "^(chore|build|ci)(\(.+\))?:" {
                Write-Output "  ğŸ”¨ MudanÃ§a de manutenÃ§Ã£o: $commit"
              }
            }
          }

          # Determinar tipo de mudanÃ§a com lÃ³gica melhorada
          if ($isBreakingChange) {
            $changeType = "major"
            Write-Output "ğŸ“Š Resultado: MAJOR RELEASE (breaking change detectado)"
          } elseif ($isMajorFeature -or $hasNewDependencies -or $hasNativeChanges) {
            $changeType = "minor"
            Write-Output "ğŸ“Š Resultado: MINOR RELEASE (nova feature/dependÃªncia/mudanÃ§a nativa)"
          } else {
            $changeType = "patch"
            Write-Output "ğŸ“Š Resultado: PATCH (correÃ§Ã£o/melhoria menor)"
          }

          # Gerar notas da release melhoradas
          $releaseNotes = @()
          $releaseNotes += "### ğŸ“ MudanÃ§as nesta versÃ£o"
          $releaseNotes += ""

          # Categorizar commits
          $features = @()
          $fixes = @()
          $improvements = @()
          $others = @()

          foreach ($commit in $commits) {
            if ($commit -notlike "*chore:*" -and $commit -notlike "*ci:*" -and $commit -notlike "*build:*") {
              switch -Regex ($commit) {
                "^feat" { $features += $commit }
                "^fix" { $fixes += $commit }
                "^(perf|style|refactor)" { $improvements += $commit }
                default { $others += $commit }
              }
            }
          }

          # Adicionar seÃ§Ãµes organizadas
          if ($features.Count -gt 0) {
            $releaseNotes += "#### âœ¨ Novas Funcionalidades"
            $features | ForEach-Object { $releaseNotes += "- $_" }
            $releaseNotes += ""
          }

          if ($fixes.Count -gt 0) {
            $releaseNotes += "#### ğŸ› CorreÃ§Ãµes"
            $fixes | ForEach-Object { $releaseNotes += "- $_" }
            $releaseNotes += ""
          }

          if ($improvements.Count -gt 0) {
            $releaseNotes += "#### ğŸ”§ Melhorias"
            $improvements | ForEach-Object { $releaseNotes += "- $_" }
            $releaseNotes += ""
          }

          if ($others.Count -gt 0) {
            $releaseNotes += "#### ğŸ“ Outras MudanÃ§as"
            $others | ForEach-Object { $releaseNotes += "- $_" }
            $releaseNotes += ""
          }

          # Adicionar informaÃ§Ãµes tÃ©cnicas
          if ($hasNewDependencies -or $hasNativeChanges -or $hasInfraChanges) {
            $releaseNotes += "#### ğŸ”§ Detalhes TÃ©cnicos"
            if ($hasNewDependencies) { $releaseNotes += "- ğŸ“¦ DependÃªncias atualizadas" }
            if ($hasNativeChanges) { $releaseNotes += "- ğŸ”§ MudanÃ§as em cÃ³digo nativo" }
            if ($hasInfraChanges) { $releaseNotes += "- âš™ï¸ AtualizaÃ§Ãµes de infraestrutura" }
            $releaseNotes += ""
          }

          $releaseNotesText = $releaseNotes -join "`n"

          # Set outputs com validaÃ§Ã£o
          echo "change-type=$changeType" >> $env:GITHUB_OUTPUT
          echo "is-patch-only=$isPatchOnly" >> $env:GITHUB_OUTPUT
          echo "has-breaking-changes=$isBreakingChange" >> $env:GITHUB_OUTPUT
          echo "has-new-dependencies=$hasNewDependencies" >> $env:GITHUB_OUTPUT
          echo "has-native-changes=$hasNativeChanges" >> $env:GITHUB_OUTPUT

          echo "release-notes<<EOF" >> $env:GITHUB_OUTPUT
          echo $releaseNotesText >> $env:GITHUB_OUTPUT
          echo "EOF" >> $env:GITHUB_OUTPUT

          Write-Output "âœ… AnÃ¡lise de mudanÃ§as concluÃ­da"

      - name: Get Current Version
        id: version
        shell: powershell
        run: |
          Write-Output "ğŸ“‹ Obtendo versÃ£o atual do pubspec.yaml..."

          try {
            $pubspecContent = Get-Content pubspec.yaml -Raw -ErrorAction Stop
            $versionMatch = $pubspecContent | Select-String 'version:\s*(.+)'
            
            if ($versionMatch) {
              $currentVersion = $versionMatch.Matches[0].Groups[1].Value.Trim()
              Write-Output "âœ… VersÃ£o atual encontrada: $currentVersion"
              
              # Validar formato da versÃ£o
              if ($currentVersion -match '^\d+\.\d+\.\d+\+\d+$') {
                Write-Output "âœ… Formato de versÃ£o vÃ¡lido"
              } else {
                Write-Output "âš ï¸ Formato de versÃ£o pode estar incorreto: $currentVersion"
              }
            } else {
              $currentVersion = "1.0.14+2"
              Write-Output "âš ï¸ VersÃ£o nÃ£o encontrada no pubspec.yaml, usando fallback: $currentVersion"
            }
          } catch {
            $currentVersion = "1.0.14+2"
            Write-Output "âŒ Erro ao ler pubspec.yaml: $_"
            Write-Output "ğŸ”„ Usando versÃ£o fallback: $currentVersion"
          }

          # Parse da versÃ£o atual com validaÃ§Ã£o robusta
          try {
            $versionParts = $currentVersion -split '\+'
            $semverParts = $versionParts[0] -split '\.'
            $buildNumber = if ($versionParts.Length -gt 1) { [int]$versionParts[1] } else { 2 }

            $major = [int]$semverParts[0]
            $minor = [int]$semverParts[1]
            $patch = [int]$semverParts[2]
            
            Write-Output "ğŸ“Š VersÃ£o parseada: Major=$major, Minor=$minor, Patch=$patch, Build=$buildNumber"
          } catch {
            Write-Output "âŒ Erro ao parsear versÃ£o '$currentVersion': $_"
            Write-Output "ğŸ”„ Usando valores padrÃ£o"
            $major = 1
            $minor = 0
            $patch = 14
            $buildNumber = 2
          }

          # Calcular nova versÃ£o baseada no tipo de mudanÃ§a
          $changeType = "${{ steps.analyze.outputs.change-type }}"

          switch ($changeType) {
            "major" { 
              $major += 1
              $minor = 0
              $patch = 0
              $buildNumber += 1
              Write-Output "ğŸ“ˆ Major version bump: $major.0.0+$buildNumber"
            }
            "minor" { 
              $minor += 1
              $patch = 0
              $buildNumber += 1
              Write-Output "ğŸ“ˆ Minor version bump: $major.$minor.0+$buildNumber"
            }
            "patch" { 
              $patch += 1
              $buildNumber += 1
              Write-Output "ğŸ“ˆ Patch version bump: $major.$minor.$patch+$buildNumber"
            }
            default { 
              $patch += 1
              $buildNumber += 1
              Write-Output "ğŸ“ˆ Default patch bump: $major.$minor.$patch+$buildNumber"
            }
          }

          $newVersion = "$major.$minor.$patch+$buildNumber"

          echo "current-version=$currentVersion" >> $env:GITHUB_OUTPUT
          echo "new-version=$newVersion" >> $env:GITHUB_OUTPUT

          Write-Output "ğŸ“Š Versionamento final:"
          Write-Output "  Atual: $currentVersion"
          Write-Output "  Nova: $newVersion"
          Write-Output "  Tipo: $changeType"

      - name: Determine Action
        id: decision
        shell: powershell
        run: |
          Write-Output "ğŸ¯ Determinando aÃ§Ã£o da pipeline..."

          $changeType = "${{ steps.analyze.outputs.change-type }}"
          $isPatchOnly = "${{ steps.analyze.outputs.is-patch-only }}"
          $branch = "${{ inputs.branch_name }}"
          $hasBreakingChanges = "${{ steps.analyze.outputs.has-breaking-changes }}"

          Write-Output "ğŸ“‹ ParÃ¢metros de decisÃ£o:"
          Write-Output "  Branch: $branch"
          Write-Output "  Tipo de mudanÃ§a: $changeType"
          Write-Output "  Apenas patch: $isPatchOnly"
          Write-Output "  Breaking changes: $hasBreakingChanges"

          # LÃ³gica melhorada de decisÃ£o
          if ($branch -like "*patch*" -or $branch -eq "1.0.14+1") {
            if ($changeType -eq "major" -and $hasBreakingChanges -eq "true") {
              $action = "release"
              Write-Output "ğŸš€ Breaking change detectado em branch de patch â†’ RELEASE forÃ§ada"
            } else {
              $action = "patch"
              Write-Output "ğŸ”§ Branch de patches detectada â†’ PATCH"
            }
          } elseif ($changeType -eq "major") {
            $action = "release"
            Write-Output "ğŸš€ Major change â†’ RELEASE obrigatÃ³ria"
          } elseif ($changeType -eq "minor") {
            $action = "release"
            Write-Output "ğŸš€ Minor change â†’ RELEASE (nova funcionalidade)"
          } elseif ($isPatchOnly -eq "true") {
            $action = "patch"
            Write-Output "ğŸ”§ Apenas mudanÃ§as pequenas â†’ PATCH"
          } else {
            $action = "release"
            Write-Output "ğŸš€ MudanÃ§as diversas â†’ RELEASE (seguro)"
          }

          # Verificar se deve prosseguir
          $shouldProceed = "true"

          # VerificaÃ§Ãµes de sanidade aprimoradas
          try {
            if ("${{ secrets.SHOREBIRD_TOKEN }}" -eq "") {
              Write-Output "âš ï¸ SHOREBIRD_TOKEN nÃ£o configurado - pipeline pode falhar"
            } else {
              Write-Output "âœ… SHOREBIRD_TOKEN disponÃ­vel"
            }
            
            # Verificar configuraÃ§Ã£o do Shorebird (nÃ£o bloqueante)
            try {
              $env:SHOREBIRD_TOKEN = "${{ secrets.SHOREBIRD_TOKEN }}"
              $shorebirdCheck = shorebird doctor 2>&1
              Write-Output "âœ… Shorebird acessÃ­vel"
            } catch {
              Write-Output "âš ï¸ Problema na verificaÃ§Ã£o do Shorebird: $_"
              Write-Output "ğŸ”„ Continuando mesmo assim..."
            }
          } catch {
            Write-Output "âš ï¸ Erro nas verificaÃ§Ãµes: $_"
            # NÃ£o falhar a pipeline por problemas de verificaÃ§Ã£o
          }

          echo "action=$action" >> $env:GITHUB_OUTPUT
          echo "should-proceed=$shouldProceed" >> $env:GITHUB_OUTPUT

          Write-Output "ğŸ“Š DecisÃ£o final:"
          Write-Output "  AÃ§Ã£o: $action"
          Write-Output "  Deve prosseguir: $shouldProceed"
          Write-Output "  VersÃ£o alvo: ${{ steps.version.outputs.new-version }}"

      - name: Summary
        shell: powershell
        run: |
          Write-Output ""
          Write-Output "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          Write-Output "â•‘                   ANÃLISE CONCLUÃDA                         â•‘"
          Write-Output "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Output ""
          Write-Output "ğŸ“‹ RESUMO DA ANÃLISE"
          Write-Output "==================="
          Write-Output "ğŸ¯ AÃ§Ã£o decidida: ${{ steps.decision.outputs.action }}"
          Write-Output "ğŸ“Š Tipo de mudanÃ§a: ${{ steps.analyze.outputs.change-type }}"
          Write-Output "ğŸ“± Versionamento: ${{ steps.version.outputs.current-version }} â†’ ${{ steps.version.outputs.new-version }}"
          Write-Output "ğŸŒŸ Branch: ${{ inputs.branch_name }}"
          Write-Output "âœ… Prosseguir: ${{ steps.decision.outputs.should-proceed }}"
          Write-Output "â° Timestamp: $(Get-Date -Format 'HH:mm:ss')"
          Write-Output "==================="
          Write-Output ""
          
          $action = "${{ steps.decision.outputs.action }}"
          if ($action -eq "release") {
            Write-Output "ğŸš€ PRÃ“XIMA ETAPA: CRIAÃ‡ÃƒO DE RELEASE"
            Write-Output "  ğŸ“¦ Nova release base serÃ¡ criada no Shorebird"
            Write-Output "  ğŸ·ï¸ Tag Git serÃ¡ criada: v${{ steps.version.outputs.new-version }}"
            Write-Output "  ğŸ“ GitHub Release serÃ¡ publicada"
            Write-Output "  ğŸ”§ Futuros patches serÃ£o baseados nesta release"
          } else {
            Write-Output "ğŸ”§ PRÃ“XIMA ETAPA: CRIAÃ‡ÃƒO DE PATCH"
            Write-Output "  ğŸ“¥ Patch serÃ¡ criado no Shorebird"
            Write-Output "  ğŸ”„ UsuÃ¡rios receberÃ£o update automÃ¡tico"
            Write-Output "  âš¡ Download incremental menor"
            Write-Output "  ğŸ›¡ï¸ Rollback disponÃ­vel se necessÃ¡rio"
          }
          Write-Output ""
          Write-Output "ğŸ‰ AnÃ¡lise bem-sucedida! Prosseguindo para prÃ³xima etapa..."